import axios from 'axios';

import { AuthEventNames } from '../constants';
import Emitter from '../emitter';
import RefreshTokenHandler from '../refresh-token-handler';
import { ensureAuthOptions, isClientErrorStatusCode } from '../utils';

import type {
  AuthCallback,
  AuthCallbackUnsubscriber,
  AuthResponseCallback,
  IAuthManager,
  IAuthOptions,
  IEmitter,
  IStorage,
  ISignedInOptions,
} from '../';
import type { IRefreshTokenHandler } from '../refresh-token-handler';
import type { IAuthResult } from '../types';
import type { AxiosInstance, AxiosResponse } from 'axios';
import type { IAuthData } from 'src/types/auth-manager';

export default class AuthManager<IUser, ISignInParams, IsSignedIn extends boolean>
  implements IAuthManager<IUser, ISignInParams>
{
  protected _isSignedIn: boolean;

  protected _isDisposed: boolean;

  protected readonly _emitter: IEmitter;

  protected readonly _refreshTokenHandler: IRefreshTokenHandler;

  protected readonly _storage: IStorage;

  protected readonly _options: Required<IAuthOptions<IUser, ISignInParams>>;

  get options(): Required<Readonly<IAuthOptions<IUser, ISignInParams>>> {
    return this._options;
  }

  /**
   * Instance of axios you should use to perform authorized requests
   */
  get axios(): AxiosInstance {
    return this._options.axiosInstance;
  }

  protected _bindExternalMethods() {
    this._forceRefreshToken = this._forceRefreshToken.bind(this);
    this._createSubscription = this._createSubscription.bind(this);

    this.getAuthorizationHeader = this.getAuthorizationHeader.bind(this);
    this.getUser = this.getUser.bind(this);
    this.getAccessToken = this.getAccessToken.bind(this);
    this.getRefreshToken = this.getRefreshToken.bind(this);
    this.getAuthData = this.getAuthData.bind(this);

    this.setAuth = this.setAuth.bind(this);
    this.updateUser = this.updateUser.bind(this);
    this.isSignedIn = this.isSignedIn.bind(this);
    this.signIn = this.signIn.bind(this);
    this.signOut = this.signOut.bind(this);
    this.refreshToken = this.refreshToken.bind(this);
    this.dispose = this.dispose.bind(this);

    this.onSignInFailed = this.onSignInFailed.bind(this);
    this.onSignedIn = this.onSignedIn.bind(this);
    this.onSignedOut = this.onSignedOut.bind(this);
    this.onStateChanged = this.onStateChanged.bind(this);
    this.onTokenRefreshed = this.onTokenRefreshed.bind(this);
  }

  constructor(
    options: IAuthOptions<IUser, ISignInParams>,
    signedInOptions?: ISignedInOptions<IsSignedIn, IUser>,
  ) {
    this._bindExternalMethods();

    this._isSignedIn = signedInOptions?.isSignedIn ?? false;
    this._isDisposed = false;

    this._options = ensureAuthOptions(options);
    this._storage = this._options.storage;

    this._emitter = new Emitter();
    this._refreshTokenHandler = new RefreshTokenHandler({
      axiosInstance: this._options.axiosInstance,
      forceRefreshToken: this._forceRefreshToken,
      getAuthorizationHeader: this.getAuthorizationHeader,
      isSignedIn: this.isSignedIn,
      signOut: this.signOut,
    });

    this._signInOnInit(signedInOptions);
  }

  /**
   * @returns true if dispose method was called on this instance.
   */
  isDisposed(): boolean {
    return this._isDisposed;
  }

  protected _ensureInstanceNotDisposed() {
    if (this._isDisposed) {
      throw new Error('Instance was disposed');
    }
  }

  /**
   * @returns formatted http header value generated by `options.buildAuthorizationHeader`.
   */
  getAuthorizationHeader(): string | null {
    return this.options.buildAuthorizationHeader(this);
  }

  /**
   * @returns `IUser` model if the user is logged in or `null` otherwise.
   */
  getUser(): IUser | null {
    try {
      return this._storage.getItem<IUser>(this._options.storageKeys.user);
    } catch {
      return null;
    }
  }

  /**
   * @returns `accessToken` if the user is logged in or `null` otherwise.
   */
  getAccessToken(): string | null {
    try {
      return this._storage.getItem<string>(this._options.storageKeys.accessToken);
    } catch {
      return null;
    }
  }

  /**
   * @returns `refreshToken` if the user is logged in or `null` otherwise.
   */
  getRefreshToken(): string | null {
    try {
      return this._storage.getItem<string>(this._options.storageKeys.refreshToken);
    } catch {
      return null;
    }
  }

  /**
   * @returns combined data from `getUser`, `getAccessToken`, `getRefreshToken`, `isSignedIn` methods
   */
  getAuthData(): IAuthData<IUser> {
    return {
      user: this.getUser(),
      accessToken: this.getAccessToken(),
      refreshToken: this.getRefreshToken(),
      isSignedIn: this.isSignedIn(),
    };
  }

  protected _updateAuthHeader() {
    this._refreshTokenHandler.updateAuthHeader(this.getAuthorizationHeader());
  }

  protected _setTokens(
    accessToken: string | null,
    refreshToken: string | null,
    user: IUser | null,
  ) {
    this._storage.multiSet({
      [this.options.storageKeys.accessToken]: accessToken,
      [this.options.storageKeys.refreshToken]: refreshToken,
      [this.options.storageKeys.user]: user,
    });
  }

  protected _clearStorage() {
    return this._storage.multiRemove(Object.values(this._options.storageKeys));
  }

  // Update store and axios headers when signedInOptions passed
  protected _signInOnInit(signedInOptions?: ISignedInOptions<IsSignedIn, IUser>) {
    if (signedInOptions?.accessToken || signedInOptions?.refreshToken) {
      this._setTokens(
        signedInOptions?.accessToken,
        signedInOptions?.refreshToken,
        signedInOptions?.user,
      );
      this._updateAuthHeader();
    }
  }

  protected _emitEvents(...args: AuthEventNames[]) {
    args.forEach((eventName) => {
      this._emitter.emit(eventName, this);
    });
  }

  protected async _forceRefreshToken() {
    const authResult = await this._options.refreshToken(this);
    const { accessToken, refreshToken } = authResult.data;

    this._storage.multiSet({
      [this.options.storageKeys.accessToken]: accessToken,
      [this.options.storageKeys.refreshToken]: refreshToken,
    });
    this._updateAuthHeader();

    const userResult = await this._options.getUser(this);

    this._storage.setItem(this.options.storageKeys.user, userResult.data);

    this._isSignedIn = true;
    this._emitEvents(AuthEventNames.onAuthStateChanged, AuthEventNames.onTokenRefreshed);
  }

  protected async _forceSignOut() {
    await this._clearStorage();
    this._isSignedIn = false;

    try {
      await this._options.signOut(this);
    } catch {
      // Do nothing if sign out request failed.
      // We still cleared auth data on device.
    }

    this._updateAuthHeader();
    this._emitEvents(AuthEventNames.onAuthStateChanged, AuthEventNames.onSignedOut);
  }

  /**
   *
   * @param user User
   * @param authResult accessToken & refreshToken
   * @emits `AuthEventNames.onAuthStateChanged` & `AuthEventNames.onSignedIn` events
   *
   * @description This method will save the authentication token
   * and the user information in the storage.
   */
  setAuth(user: IUser, authResult: IAuthResult): this {
    this._ensureInstanceNotDisposed();

    this._setTokens(authResult.accessToken, authResult.refreshToken, user);

    this._isSignedIn = true;

    this._updateAuthHeader();

    this._emitEvents(AuthEventNames.onAuthStateChanged, AuthEventNames.onSignedIn);

    return this;
  }

  /**
   *
   * @param user set of fields for the `IUser` model to be updated.
   * @emits `AuthEventNames.onAuthStateChanged` event
   *
   * @description Updates the user data in the storage.
   */
  updateUser(user: Partial<IUser>): this {
    this._ensureInstanceNotDisposed();

    const oldUser = this.getUser();
    this._storage.setItem(this._options.storageKeys.user, {
      ...(oldUser || {}),
      ...user,
    });

    this._emitEvents(AuthEventNames.onAuthStateChanged);

    return this;
  }

  /**
   * @returns `true` if the user is signed in.
   */
  isSignedIn(): boolean {
    return this._isSignedIn;
  }

  /**
   *
   * @param signInParams user credentials required for the `options.signIn` request
   *
   * @description This method will call the `signIn` method from `IAuthOptions`
   * and then save the authentication token and get the user information.
   * All received data is stored in the storage.
   */
  async signIn(signInParams: ISignInParams): Promise<this> {
    this._ensureInstanceNotDisposed();

    if (this._isSignedIn) {
      return this;
    }

    let authResult: AxiosResponse<IAuthResult>;

    try {
      authResult = await this._options.signIn(signInParams, this);

      this._setTokens(authResult.data.accessToken, authResult.data.refreshToken, this.getUser());
      this._updateAuthHeader();
    } catch (e) {
      this._emitter.emit(AuthEventNames.onAuthFailed, axios.isAxiosError(e) ? e.response : e);
      throw e;
    }

    const userResult = await this._options.getUser(this);

    this.setAuth(userResult.data, authResult.data);

    return this;
  }

  /**
   * @description This method will call the `signOut` method from `IAuthOptions`
   * and then clear the authentication token and all user information
   */
  async signOut(): Promise<this> {
    this._ensureInstanceNotDisposed();

    if (this._isSignedIn) {
      await this._forceSignOut();
    }

    return this;
  }

  /**
   *
   * @param refreshToken The `refreshToken` string. This parameter is optional,
   * the result of `authManager.getRefreshToken()` is used as default parameter.
   *
   * @emits `AuthEventNames.onAuthStateChanged` & `AuthEventNames.onTokenRefreshed` events
   */
  async refreshToken(refreshToken?: string): Promise<this> {
    this._ensureInstanceNotDisposed();

    try {
      if (refreshToken) {
        this._storage.setItem(this.options.storageKeys.refreshToken, refreshToken);
      }

      await this._forceRefreshToken();
    } catch (error) {
      if (axios.isAxiosError(error) && isClientErrorStatusCode(error.response?.status)) {
        await this._forceSignOut();
      }
    }
    return this;
  }

  /**
   * @description Removes all active event listeners on this object.
   * Remove response interceptor that refreshes token from axios instance.
   * Instance should not be used after disposing!
   */
  dispose(): void {
    this._emitter.removeAllListeners();
    this._refreshTokenHandler.dispose();
    this._isDisposed = true;
  }

  protected _createSubscription<
    EventName extends AuthEventNames,
    IData = unknown,
    IConfigData = unknown,
  >(eventName: EventName) {
    this._ensureInstanceNotDisposed();

    return (
      callback: AuthResponseCallback<IData, IConfigData> & AuthCallback<IUser, ISignInParams>,
    ): AuthCallbackUnsubscriber => {
      this._emitter.addListener(eventName, callback);

      return () => {
        this._emitter.removeListener(eventName, callback);
      };
    };
  }

  onSignedIn = this._createSubscription(AuthEventNames.onSignedIn).bind(this);

  onSignedOut = this._createSubscription(AuthEventNames.onSignedOut).bind(this);

  onTokenRefreshed = this._createSubscription(AuthEventNames.onTokenRefreshed).bind(this);

  onStateChanged = this._createSubscription(AuthEventNames.onAuthStateChanged).bind(this);

  onSignInFailed = this._createSubscription(AuthEventNames.onAuthFailed).bind(this);
}
